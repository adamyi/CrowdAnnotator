/**
 * Part of PII-Scrubber project.
 * Main JavaScript code for crowd interface.
 *
 * @author adamyi
 */

var SelectionUtils = {};

/**
 * Returns an object with 2 properties: a boolean value indicating if #child was found in the currently iterating
 * set of child nodes, and an integer value representing how many characters of textContent were examined in that same
 * iteration.
 * @private
 * @param {Node} child
 * @param {Node} container
 * @returns {offset: number, found: boolean}
 */
SelectionUtils.getCharacterCountToNodeRecursive = function(child, container) {
    var response = {
        offset: 0,
        found: false
    };
    var current = container.firstChild;
    loop: while (current) {
        if (current == child) {
            response.found = true;
            break;
        }
        switch (current.nodeType) {
            case 3:
                response.offset += current.textContent.length;
                break;
            case 1:
                var childResponse = arguments.callee(child, current);
                response.offset += childResponse.offset;
                if (childResponse.found) {
                    response.found = true;
                    break loop;
                }
                break;
        }
        current = current.nextSibling;
    }
    return response;
};

/**
 * Returns the number of characters of text content preceding #child, in #container.
 * @param {Node} child
 * @param {Node} container
 * @returns {number}
 */
SelectionUtils.getCharacterCountToNode = function(child, container) {
    container = container || document.body;
    if (!container.contains(child)) {
        return -1;
        throw new Error('child must be descendant of container');
    }
    return SelectionUtils.getCharacterCountToNodeRecursive(child, container).offset;
};

/**
 * Convenience method to count the number of characters of text content to the start of the current selection.
 * @param range
 * @param container
 * @returns {number}
 */
SelectionUtils.getSelectionStartOffset = function(range, container) {
    var tmp = SelectionUtils.getCharacterCountToNode(range.startContainer, container);
    if (tmp == -1)
        return -1;
    return range.startOffset + tmp;
};

/**
 * Convenience method to count the number of characters of text content to the end of the current selection.
 * @param range
 * @param container
 * @returns {number}
 */
SelectionUtils.getSelectionEndOffset = function(range, container) {
    tmp = SelectionUtils.getCharacterCountToNode(range.endContainer, container);
    if (tmp == -1)
        return -1;
    return range.endOffset + tmp;
};

function getCookie(cname) {
    var name = cname + "=";
    var decodedCookie = decodeURIComponent(document.cookie);
    var ca = decodedCookie.split(';');
    for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ') {
            c = c.substring(1);
        }
        if (c.indexOf(name) == 0) {
            return c.substring(name.length, c.length);
        }
    }
    return "";
}

function setCookie(cname, cvalue, exdays) {
    var d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    var expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
}

/*
 * Begin JS generated by category program
 */
var types = new Array();
var aliases = new Array();
types["01person"] = new Array("person", "user");
aliases["01person"] = new Array("person name", "user name");
// Other place moved to the end by Adam (non-alphabetical order)
types["02location"] = new Array("city", "country", "state", "address", "other_place");
aliases["02location"] = new Array("city", "country", "state", "street address", "other place name");
types["03datetime"] = new Array("date", "time");
aliases["03datetime"] = new Array("date", "time of day");
types["04org"] = new Array("job", "group");
aliases["04org"] = new Array("occupation", "social group");
types["05number"] = new Array("quantity");
aliases["05number"] = new Array("quantity");
types["contact"] = new Array("email", "fax_phone");
aliases["contact"] = new Array("email address", "fax/phone number");
types["event"] = new Array("event");
aliases["event"] = new Array("event name");
types["id"] = new Array("code");
aliases["id"] = new Array("code");
types["org"] = new Array("org");
aliases["org"] = new Array("organization");
types["prod"] = new Array("product");
aliases["prod"] = new Array("product/service/app name");
types["specificterm"] = new Array("term");
aliases["specificterm"] = new Array("specific term");
types["url"] = new Array("url");
aliases["url"] = new Array("url");
var typeNames = new Array();
typeNames["person"] = "01person";
typeNames["user"] = "01person";
typeNames["city"] = "02location";
typeNames["country"] = "02location";
typeNames["other_place"] = "02location";
typeNames["state"] = "02location";
typeNames["address"] = "02location";
typeNames["date"] = "03datetime";
typeNames["time"] = "03datetime";
typeNames["job"] = "04org";
typeNames["group"] = "04org";
typeNames["quantity"] = "05number";
typeNames["email"] = "contact";
typeNames["fax_phone"] = "contact";
typeNames["event"] = "event";
typeNames["code"] = "id";
typeNames["org"] = "org";
typeNames["product"] = "prod";
typeNames["term"] = "specificterm";
typeNames["url"] = "url";
/*
 * End JS generated by category program
 */

var select;
var offset_start;
var offset_end;
var offset_all;

var tutorial_step = 1;
var initial_task = true;
var undo_counter;

var alert_id = 0;
var renderedHTML;

var originalText;
var rawResult;

var submit_confirmed;

function init() {
    offset_start = new Array();
    offset_end = new Array();
    offset_all = new Array();
    renderedHTML = new Array();
    originalText = new Array();
}

function postInit() {
    rawResult = Object.assign({}, originalText);
    $("#form_content").html("");
    for (msg_id in originalText) {
        offset_start[msg_id] = new Array();
        offset_end[msg_id] = new Array();
        offset_all[msg_id] = new Array();
        $("#form_content").append("<div class=\"form-control scrub-textbox\" style=\"min-width: 100%; height: auto;\" id=\"input_" + msg_id + "\" name=\"msg_" + msg_id + "\" autofocus contenteditable></div>");
    }
    select = '';
    submit_confirmed = false;
    undo_counter = 0;
}

function loader(item) {
    var size = $(item).css('line-height');
    var string = '<div class="loader" style="width: ' + size + ' !important; height: ' + size + ' !important;"><div class="circle"></div><div class="circle"></div><div class="circle"></div><div class="circle"></div><div class="circle"></div></div>';
    var width = $(item).css('width');
    var height = $(item).css('height');
    $(item).css('width', width, 'important');
    $(item).css('height', height, 'important');
    $(item).html(string);
}

function renderPop(theType, id) {
    var result = '';
    var preview = '(custom) ' + theType;
    for (type in types) {
        for (cat in types[type]) {
            result += '<span class="badge scrubbed-' + type + ' scrubChoice" type="' + types[type][cat] + '" data-id="' + id + '"';
            if (types[type][cat] == theType) {
                result += ' selected><b>(SELECTED) ' + aliases[type][cat] + '</b>';
                preview = aliases[type][cat];
            } else
                result += '>' + aliases[type][cat];
            result += '</span>&nbsp;';
        }
        result += '<br>';
    }
    if (preview == '(custom) none') {
        preview = 'Please choose a category.'; //'Scrub a new word';
        result += '<span class="badge scrubbed-default scrubChoice" type="none" data-id="' + id + '">None</span>';
    } else {
        preview = 'Currently selected: ' + preview;
        result += '<span class="badge scrubbed-default scrubChoice" type="none" data-id="' + id + '">Undo</span>';
    }
    $('#type_name_preview-' + id).html(preview);
    result += '&nbsp;<span class="badge scrubbed-default scrubCustom" type="custom" data-id="' + id + '">Add New</span>';
    result += '<br><div id="type_name_preview-' + id + '" style="text-align:center;">' + preview + '</div>';
    return result;
}

function render() {
    for (var msg_id in rawResult) {
        $("#input_" + msg_id).html(rawResult[msg_id].replace(/\n/g, "\n<br>"));
        nth = 0;
        $("#input_" + msg_id + " scrub").each(function() {
            nth++;
            $(this).replaceWith("<span class='scrubbed scrubbed-" + typeNames[$(this).attr('type')] + "' data-toggle='popover' data-placement='top' data-content='" + renderPop($(this).attr('type'), msg_id + "_" + nth) + "'>" + $(this).text() + "</span>");
        });
        renderedHTML[msg_id] = $("#input_" + msg_id).html();
    }
    $(".scrubbed").popover({
        html: true
    });
}

function restoreRendered() {
    for (msg_id in renderedHTML) {
        $("#input_" + msg_id).html(renderedHTML[msg_id]);
    }
    $(".scrubbed").popover({
        html: true
    });
}

function resetTask() {
    postInit();
    render();
}

function submitTask() {
    if ($('#submit').html() == "Restart") {
        location.reload();
        return;
    }
    $('#msg').val(JSON.stringify(rawResult));
    var data = $('form').serialize();
    if (data.indexOf("%3C%2Fscrub%3E") == -1 && submit_confirmed == false) {
        alert("Please double check that there is no sensitive information in the text, and click `Next` button again");
        submit_confirmed = true;
        return;
    }
    $(".alert-error").fadeOut();
    submit_confirmed = false;
    $("#submit").prop('disabled', true);
    $("#reset").hide();
    loader($("#submit"));
    $.ajax({
        type: 'POST',
        url: '/scrubber/saveScrub',
        data: data,
        success: function(data) {
            //alert('success');
            if (data == "OK") {
                init();
                getTask();
                $("#submit").removeAttr('style');
                $("#submit").html("Next Task");
                $("#reset").show();
            } else {
                originalText = data;
                postInit();
                render();
                showError("You have made too many mistakes in the warm-up task. Check the answer below and restart when you are ready.");
                $("#submit").prop('disabled', false);
                $("#submit").removeAttr('style');
                $("#submit").html("Restart");
            }
        },
        error: function() {
            showError("An error occured while submitting");
            $("#submit").removeAttr('style');
            $("#submit").html("Retry");
        }
    });
}

$(document).on('mouseenter', '.scrubCustom', function(e) {
    var $this = $(this),
        id = $this.attr('data-id');
    $('#type_name_preview-' + id).html('<form class="form-inline" role="form"><div class="form-group"><input type="text" class="form-control customTextbox" placeholder="Custom category"></div><a href="#" data-id="' + id + '" type="addCustom" class="btn btn-default scrubChoice">Add</a></form>');
});

$(document).on('mouseleave', '.scrubChoice', function(e) {
    var $this = $(this),
        id = $this.attr('data-id'),
        kind = $this.attr('type');
    //if ($this.attr('selected') == 'selected')
    //    return;
    //$this.html('&nbsp;');
    if (kind != 'addCustom')
        $('#type_name_preview-' + id).html('');
});

function selectedMsg() {
    var start, end;
    for (msg_id in originalText) {
        input_dom = document.getElementById('input_' + msg_id);
        end = SelectionUtils.getSelectionEndOffset(select, input_dom) - 1;
        start = SelectionUtils.getSelectionStartOffset(select, input_dom);
        if (end - start > -1)
            return [msg_id, start, end];
    }
    return null;
}

function is_space(x) {
    return (" \u2002\u2003\u2009\t\n".indexOf(x) != -1);
}

function is_separator(x) {
    return !((x >= 'a' && x <= 'z') || (x >= 'A' && x <= 'Z') || (x >= '0' && x <= '9') || x == '<' || x == '>');
    return (" \u2002\u2003\u2009\t\n@!#$%^&*()_+[]{}?:;|'\"\\,./~`-=".indexOf(x) != -1);
}

function is_bracket(x) {
    return x == '<' || x == '>';
}

function addScrub(id, kind) {
    submit_confirmed = false;
    msg = id.split("_")[0];
    if (msg == 'new') {
        if (kind != 'none') {
            var msg = selectedMsg(),
                start = msg[1],
                end = msg[2],
                selected_text = select.toString();
            msg = msg[0];
            for (i = 0 ; i < selected_text.length ; i++) {
                if (is_space(selected_text[i])) {
                    start++;
                } else
                    break;
            }
            for (i = selected_text.length - 1 ; i > -1 ; i--) {
                if (is_space(selected_text[i])) {
                    end--;
                } else
                    break;
            }
            var text = rawResult[msg],
                start_offsetted = start,
                end_offsetted = end;
            for (key in offset_start[msg]) {
                if (parseInt(key) <= start)
                    start_offsetted += offset_start[msg][key];
                if (parseInt(key) <= end)
                    end_offsetted += offset_start[msg][key];
            }
            for (key in offset_end[msg]) {
                if (parseInt(key) <= start)
                    start_offsetted += offset_end[msg][key];
                if (parseInt(key) <= end)
                    end_offsetted += offset_end[msg][key];
            }
            start--;
            start_offsetted--;
            while(!(is_separator(text[start_offsetted]) || is_bracket(text[start_offsetted]))) {
                if (start > 0) {
                    start--;
                    start_offsetted--;
                } else
                    break;
            }
            start++;
            start_offsetted++;
            end++;
            end_offsetted++;
            while(!(is_separator(text[end_offsetted]) || is_bracket(text[end_offsetted]))) {
                if (end_offsetted < text.length - 1) {
                    end++;
                    end_offsetted++;
                } else
                    break;
            }
            end--;
            end_offsetted--;
            var scrubbedContent = text.substring(start_offsetted, end_offsetted + 1);
            if (scrubbedContent.indexOf("<scrub") != -1 || scrubbedContent.indexOf("</scrub>") != -1) {
                showError("Cannot add because part of the selected string is already added!");
                $('#scrubPopover').hide();
                return;
            }
            if (end < start) {
                showError("Cannot add because selected string is empty");
                $('#scrubPopover').hide();
                return;
            }
            addSameScrub(msg, scrubbedContent, kind);
            //offset_all[msg][start] += 15 + kind.length - offset_start[msg][start];
            //offset_start[msg][start] = 15 + kind.length;
            //offset_all[msg][end] += 8 - offset_end[msg][end];
            //offset_end[msg][end] = 8;
            //$('#' + msg + '_raw').val(text.substring(0, start_offsetted) + "<scrub type='" + kind + "'>" + scrubbedContent + "</scrub>" + text.substring(end_offsetted + 1));
            //render();
        }
        $('#scrubPopover').hide();
    } else {
        id = parseInt(id.split("_")[1]);
        var nth = 0,
            text = rawResult[msg];
        if (kind == 'none') {
            text = text.replace(/<scrub type='\w*'>/g, function(match, i, original) {
                nth++;
                return (nth === id) ? "" : match;
            });
            nth = 0;
            text = text.replace(/<\/scrub>/g, function(match, i, original) {
                nth++;
                return (nth === id) ? "" : match;
            });
            nth = 0;
            for (key in offset_start[msg]) {
                if (offset_start[msg][key] > 15)
                    nth++;
                if (nth == id) {
                    if (!isNaN(offset_all[msg][key]))
                        offset_all[msg][key] -= offset_start[msg][key] || 0;
                    offset_start[msg][key] = 0;
                    break;
                }
            }
            nth = 0;
            for (key in offset_end[msg]) {
                if (offset_end[msg][key] == 8)
                    nth++;
                if (nth == id) {
                    if (!isNaN(offset_all[msg][key]))
                        offset_all[msg][key] -= offset_end[msg][key] || 0;
                    offset_end[msg][key] = 0;
                    break;
                }
            }
            undo_counter++;
            if (undo_counter == 4) {
                showError("Run into any problems? The annotation resetting button may be able to help you.");
            }
        } else {
            text = text.replace(/<scrub type='\w*'>/g, function(match, i, original) {
                nth++;
                return (nth === id) ? "<scrub type='" + kind + "'>" : match;
            });
            nth = 0;
            for (key in offset_start[msg]) {
                if (offset_start[msg][key] > 15)
                    nth++;
                if (nth == id) {
                    if (isNaN(offset_all[msg][key]))
                        offset_all[msg][key] = 15 + kind.length;
                    else
                        offset_all[msg][key] += 15 + kind.length - (offset_start[msg][key] || 0);
                    offset_start[msg][key] = 15 + kind.length;
                    break;
                }
            }
        }
        rawResult[msg] = text;
        render();
    }
}

function addSameScrub(msg, scrubbedContent, kind) {
    str = rawResult[msg];
    index = str.lastIndexOf(scrubbedContent);
    while (index != -1) {
        start_offsetted = index;
        end_offsetted = index + scrubbedContent.length - 1;
        start = start_offsetted;
        end = end_offsetted;
        started = 0;
        if (index == 0)
            index = -1;
        else
            index = str.lastIndexOf(scrubbedContent, index - 1);

        if (start > 0 && (!is_separator(str[start - 1])))
            continue;
        if (end + 1 < str.length && (!is_separator(str[end + 1])))
            continue;

        for (key in offset_all[msg]) {
            if (parseInt(key) + offset_all[msg][key] <= start) {
                if (offset_start[msg][key] > 15)
                    started++;
                if (offset_end[msg][key] == 8)
                    started--;
                start -= offset_all[msg][key];
                end -= offset_all[msg][key];
            }
        }
        if (started > 0)
            continue;
        if (isNaN(offset_all[msg][start]))
            offset_all[msg][start] = 15 + kind.length;
        else
            offset_all[msg][start] += 15 + kind.length - (offset_start[msg][start] || 0);
        offset_start[msg][start] = 15 + kind.length;
        if (isNaN(offset_all[msg][end + 1]))
            offset_all[msg][end + 1] = 8;
        else
            offset_all[msg][end + 1] += 8 - (offset_end[msg][end + 1] || 0);
        offset_end[msg][end + 1] = 8;
        str = str.substring(0, start_offsetted) + "<scrub type='" + kind + "'>" + scrubbedContent + "</scrub>" + str.substring(end_offsetted + 1);
        rawResult[msg] = str;
    }
    render();
}

$(document).on('click', '.scrubChoice', function(e) {
    var $this = $(this),
        id = $this.attr('data-id'),
        kind = $this.attr('type');
    if (kind == 'addCustom')
        kind = $('#type_name_preview-' + id + ' .customTextbox').val().replace(/\s+/g, '');
    addScrub(id, kind);
});

//$(document).on('mouseover', '.scrubbed', function(e) {
//    alert('mouseover');
//});
function selectPop(e) {
    //select = document.getSelection().toString().trim();
    if (select != '' && selectedMsg() != null) {
        var offset = $(this).offset();
        var left = e.pageX;
        var top = e.pageY;
        $('#scrubPopover').html(renderPop('none', 'new_' + selectedMsg()[0]));
        var theHeight = $('#scrubPopover').height();
        $('#scrubPopover').show();
        //$('#')
        //$('#scrubPopover').css({top: e.pageY, left: e.pageX });
        $('#scrubPopover').css('left', (left + 10) + 'px');
        $('#scrubPopover').css('top', (top - (theHeight / 2) - 10) + 'px');
    } else {
        $('#scrubPopover').hide();
    }
}

function showError(text) {
    $('#alerts-container').prepend("<div class=\"alert alert-error fade in\" id=\"alert_" + alert_id + "\"> <button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-hidden=\"true\">×</button> <strong>" + text + "</strong> </div>");
    //$("#alert_" + alert_id).delay(3500).fadeOut({
    //    queue: true
    //});
    alert_id++;
}

function getTask() {
    $.ajax({
        type: 'POST',
        dataType: "json",
        url: '/scrubber/getTask',
        data: {
            hit_id: $("#hit_id").val()
        },
        headers: {
            'X-CSRFToken': scrubber_csrf_token
        },
        success: function(data) {
            if (data['code'] != null) {
                $('#redeem_code').html(data['code']);
                $('#codeModal').modal();
            }
            task_type = data['result'];
            if (data['result'] > 0) {
                if (data['result'] == 2) {
                    showError("This is a warm-up task to get you ready. There will only be one warm-up task, followed by 3 normal tasks. We won't pay for warm-up task, but will provide you the code for mTurk to pay you after you finish the 3 normal tasks.");
                }

                originalText = data['sentences'];
                postInit();

                $('#task_id').val(data['task_id']);
                render();
                $("#submit").prop('disabled', false);
                $("#reset").show();
                if (initial_task) {
                    initial_task = false;
                    if (data['result'] == 2) {
                        tutorial_step = "warmup";
                        $('#introModal-5').modal("hide");
                        $('#introModal-warmup').modal({
                            backdrop: 'static',
                            keyboard: false
                        });
                    } else {
                        tutorial_step = "normal";
                        $('#introModal-5').modal("hide");
                        $('#introModal-normal').modal({
                            backdrop: 'static',
                            keyboard: false
                        });
                    }
                }
            } else {
                showError(data['msg']);
                if (initial_task) {
                    alert(data['msg']);
                }
            }
        },
        error: function() {
            showError("An error occured while fetching task");
        }
    });
}


$('.scrub-textbox').on("input", function(e) {
    if ($(e.target).hasClass('customTextbox'))
        return;
    showError("Please don't try to edit the text");
    restoreRendered();
    $('#scrubPopover').hide();
});

$(document).on('click', function(e) {
    $('[data-toggle="popover"],[data-original-title]').each(function() {
        //the 'is' for buttons that trigger popups
        //the 'has' for icons within a button that triggers a popup
        if (!$(this).is(e.target) && $(this).has(e.target).length === 0 && $('.popover').has(e.target).length === 0) {
            (($(this).popover('hide').data('bs.popover') || {}).inState || {}).click = false // fix for BS 3.3.6
        }

    });
});

$('.pop').on('shown.bs.popover', function() {
    var $pop = $(this);
    setTimeout(function() {
        $pop.popover('hide');
    }, 2000);
    setTimeout(function() {
        $pop.popover();
    }, 2200);
});

$(document).ready(function() {
    var mTurk_id = getCookie("mTurk_id");
    if (mTurk_id != "" && mTurk_id != null)
        $('#mTurk_id').val(mTurk_id);
    $('#mturkModal').modal({
        backdrop: 'static',
        keyboard: false
    });
});

$("#mTurk_id").keyup(function(event){
    if(event.keyCode == 13){
        $("#mTurk_submit").click();
    }
});

$("#mTurk_submit").click(function() {
    var mid = $('#mTurk_id').val();
    if ((mid.length < 12 || mid[0] != 'A') && mid != 'test' && mid != 'warmup') {
        alert("Please check if the ID is correct!");
        return;
    }
    setCookie("mTurk_id", mid, 20);
    $("#mturkModal").modal("hide");
    $('#introModal-1').modal({
        backdrop: 'static',
        keyboard: false
    });
});

$(".intro-continue").click(function() {
    $('#introModal-' + tutorial_step).modal("hide");
    tutorial_step++;
    $('#introModal-' + tutorial_step).modal({
        backdrop: 'static',
        keyboard: false
    });
});

$(".intro-endtutorial").click(function() {
    $(".intro-endtutorial").prop('disabled', true);
    loader(".intro-endtutorial");
    $.ajax({
        type: 'POST',
        dataType: "json",
        url: '/scrubber/getHit',
        data: {
            mTurk_id: $('#mTurk_id').val()
        },
        headers: {
            'X-CSRFToken': scrubber_csrf_token
        },
        success: function(data) {
            $("#hit_id").val(data);
            init();
            getTask();
        },
        error: function() {
            showError("An error occured while initializing HIT");
            alert("sorry, an error occured while initializing HIT");
        }
    });
});

$(".intro-complete").click(function() {
    $('#introModal-' + tutorial_step).modal("hide");
    $(document).on("mouseup", function(e) {
        if ($(e.target).hasClass('scrubbed'))
            return;
        var popovers = document.getElementsByClassName("popover");
        var i;
        for (i = 0; i < popovers.length; i++) {
            if ($.contains(popovers[i], e.target) || popovers[i] == e.target)
                return;
        }
        select = window.getSelection().getRangeAt(0);
        setTimeout(function() {
            selectPop(e)
        }, 3);
    });
});
